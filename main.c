#include <stdio.h>
#include <regex.h>
#include <string.h>
#include <ctype.h>

#define TOKEN_SIZE 256
       
regex_t regex;
regmatch_t match[1];

int regexVal;
char msgbuf[257];

struct token tokens[256];
int tokenIndex = 0;


//enum corresponding to non-terminals and terminals 
//declared within the grammar of the language.
enum type{
    V, 
    EQ,          //61 (6 mod 11)
    OBR,         //40 (7 mod 11)
    CBR,         //41 (8 mod 11)
    F,   
    COMM,       //44 (0 mod 11)
    NOT,        
    AND,         //38 (5 mod 11)
    OR,          //124 (3 mod 11)
    MULT,        //42 (9 mod 11)
    ADD,       //43 (10 mod 11)
    SUB,        //45 (1 mod 11)
    I,        
    EOL,        
    Sp,
    S,
    E          

};


/*
    Each lexeme can be represented as a token.
    type -> enum corresponding to the type of the lexeme
    value -> value of the lexeme stored as char[]
*/
struct token{
    enum type type;
    char value[TOKEN_SIZE];
};



typedef enum nodeType {
    STATE,
    TOKEN
} nodeType;

struct Node {
    nodeType type;
    union {
        int state;
        struct token *token;
    };
    struct Node *next;
};


struct Stack {
    struct Node *top;
    int size;
};






const char *strings[] = {"S", "V", "E", "F", "I", "NOT", "AND", "OR", "MULT", "ADD", "COMM", "SUB", "OBR", "CBR", "EQ"};

const char *uniKeys[] = {",","-","","|","","&","=","(",")","*","+"};
const enum type uniTypes[] = {COMM, SUB, -1 , OR, -1, AND, EQ, OBR, CBR, MULT, ADD};
const char *keywords[] = {"not", "xor", "ls", "rs", "lr", "rr"};

const int parsingTable[80][17][2] = {{{1, 3}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {3, 1}, {3, 2}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {-1,-1}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 8}, {1, 9}, {1, 10}, {1, 11}, {1, 12}, {0,0}, {2, 1}, {0,0}, {0,0}, {0,0}},
{{0,0}, {1, 13}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {0,0}, {2, 11}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 14}},
{{0,0}, {0,0}, {1, 20}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {1, 21}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 12}, {2, 12}, {2, 12}, {2, 12}, {2, 12}, {0,0}, {2, 12}, {0,0}, {0,0}, {0,0}},
{{1, 23}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {0,0}, {3, 22}},
{{1, 23}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {0,0}, {3, 24}},
{{1, 23}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {0,0}, {3, 25}},
{{1, 23}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {0,0}, {3, 26}},
{{1, 23}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {0,0}, {3, 27}},
{{1, 23}, {0,0}, {1, 4}, {0,0}, {1, 5}, {0,0}, {1, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 7}, {0,0}, {0,0}, {0,0}, {3, 28}},
{{0,0}, {0,0}, {0,0}, {1, 29}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 35}},
{{0,0}, {0,0}, {1, 36}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {1, 37}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 11}, {0,0}, {0,0}, {0,0}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 12}, {0,0}, {0,0}, {0,0}, {2, 12}, {2, 12}, {2, 12}, {2, 12}, {2, 12}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 38}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 44}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 6}, {2, 6}, {2, 6}, {2, 6}, {2, 6}, {0,0}, {2, 6}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {0,0}, {2, 11}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 8}, {2, 7}, {2, 7}, {2, 7}, {2, 7}, {0,0}, {2, 7}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 8}, {1, 9}, {2, 8}, {2, 8}, {2, 8}, {0,0}, {2, 8}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 8}, {1, 9}, {1, 10}, {2, 9}, {2, 9}, {0,0}, {2, 9}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 8}, {1, 9}, {1, 10}, {2, 10}, {2, 10}, {0,0}, {2, 10}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 8}, {1, 9}, {1, 10}, {1, 11}, {1, 12}, {0,0}, {2, 2}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 3}, {2, 3}, {2, 3}, {2, 3}, {2, 3}, {0,0}, {2, 3}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 45}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 46}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 47}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 48}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 49}},
{{0,0}, {0,0}, {0,0}, {1, 50}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 51}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 52}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 53}, {0,0}, {1, 54}, {1, 55}, {1, 56}, {1, 57}, {1, 58}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 59}},
{{0,0}, {0,0}, {1, 60}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {1, 61}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 11}, {0,0}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {2, 11}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 12}, {0,0}, {2, 12}, {2, 12}, {2, 12}, {2, 12}, {2, 12}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {1, 62}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 6}, {0,0}, {0,0}, {0,0}, {2, 6}, {2, 6}, {2, 6}, {2, 6}, {2, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 7}, {0,0}, {0,0}, {0,0}, {1, 30}, {2, 7}, {2, 7}, {2, 7}, {2, 7}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 8}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {2, 8}, {2, 8}, {2, 8}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 9}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {2, 9}, {2, 9}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 10}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {2, 10}, {2, 10}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 3}, {0,0}, {0,0}, {0,0}, {2, 3}, {2, 3}, {2, 3}, {2, 3}, {2, 3}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 63}, {0,0}, {1, 54}, {1, 55}, {1, 56}, {1, 57}, {1, 58}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {1, 64}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 65}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 66}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 67}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 68}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 69}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 70}},
{{0,0}, {0,0}, {0,0}, {1, 71}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{1, 42}, {0,0}, {1, 39}, {0,0}, {1, 40}, {0,0}, {1, 41}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 43}, {0,0}, {0,0}, {0,0}, {3, 72}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 73}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 5}, {2, 5}, {2, 5}, {2, 5}, {2, 5}, {0,0}, {2, 5}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 74}},
{{0,0}, {0,0}, {0,0}, {2, 5}, {0,0}, {0,0}, {0,0}, {2, 5}, {2, 5}, {2, 5}, {2, 5}, {2, 5}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {1, 75}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 6}, {0,0}, {2, 6}, {2, 6}, {2, 6}, {2, 6}, {2, 6}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 7}, {0,0}, {1, 54}, {2, 7}, {2, 7}, {2, 7}, {2, 7}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 8}, {0,0}, {1, 54}, {1, 55}, {2, 8}, {2, 8}, {2, 8}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 9}, {0,0}, {1, 54}, {1, 55}, {1, 56}, {2, 9}, {2, 9}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 10}, {0,0}, {1, 54}, {1, 55}, {1, 56}, {2, 10}, {2, 10}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 3}, {0,0}, {2, 3}, {2, 3}, {2, 3}, {2, 3}, {2, 3}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 76}, {0,0}, {1, 54}, {1, 55}, {1, 56}, {1, 57}, {1, 58}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {1, 77}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {1, 78}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 4}, {2, 4}, {2, 4}, {2, 4}, {2, 4}, {0,0}, {2, 4}, {0,0}, {0,0}, {0,0}},
{{1, 18}, {0,0}, {1, 15}, {0,0}, {1, 16}, {0,0}, {1, 17}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {1, 19}, {0,0}, {0,0}, {0,0}, {3, 79}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 5}, {0,0}, {2, 5}, {2, 5}, {2, 5}, {2, 5}, {2, 5}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {2, 4}, {0,0}, {0,0}, {0,0}, {2, 4}, {2, 4}, {2, 4}, {2, 4}, {2, 4}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {1, 80}, {0,0}, {0,0}, {0,0}, {1, 30}, {1, 31}, {1, 32}, {1, 33}, {1, 34}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}},
{{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {2, 4}, {0,0}, {2, 4}, {2, 4}, {2, 4}, {2, 4}, {2, 4}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}}};




int isNumber(char *string){
    while (*string != '\0'){
        if (isdigit(*string) == 0) return 0;
        string++;
    }
    return 1;
}



//very dangerous return value on failure
//explicitly check failure with type == -1
enum type getType(char *string, int len){
    if (isNumber(string)) return I;
    else{
        if (len > 1){
            for (int i = 0; i < 6; i++){
                if (strcmp((const char*)string, (const char*)keywords[i]) == 0){
                    if (i == 0) return NOT; else return F;}
            }
            return V;
        } 
        //either f or v
        else{
            int ascii = (int) *string;
            ascii = ascii % 11;
            int k = strcmp(((const char*)uniKeys[ascii]), (const char*)string);
            if (k == 0){
                if (uniTypes[ascii] != -1) return uniTypes[ascii];
            }
        }   return V;
    }
}


//tokenizes a given string.
//does not check for whitespaces and the behavior is 
//undefined for whitespaces.
struct token tokenize(char *string, int len){
    enum type type = getType(string, len);
    struct token token;
    token.type = type;
    strncpy(token.value, string, len+1);
    return token;
}


struct Stack *createStack(){
    struct Stack *stack = (struct Stack *)malloc(sizeof(struct Stack));
    stack->top = NULL;
    stack->size = 0;
    return stack;
}

void push(struct Stack *stack, nodeType type, void* data){
    struct Node *node = (struct Node *)malloc(sizeof(struct Node));
    if (type == TOKEN) {
        node->type = TOKEN;
        node->token = (struct token *)data;
    } else {
        node->type = STATE;
        node->state = (int)data;
    }
    node->next = stack->top;
    stack->top = node;
    stack->size++;
}


void* pop(struct Stack *stack){
    if (stack->size == 0){
        return NULL;
    }
    struct Node *node = stack->top;
    stack->top = node->next;
    stack->size--;
    if (node->type == TOKEN){
        struct token *data = node->token;
        free(node);
        return data;
    }
    else if (node->type == STATE){
        int data = node->state;
        free(node);
        return (void *)data;
    }
}

void* peek(struct Stack *stack){
    if (stack->size == 0){
        return NULL;
    }
    struct Node *node = stack->top;
    if (node->type == TOKEN){
        struct token *data = node->token;
        return data;
    }
    else if (node->type == STATE){
        int data = node->state;
        return (void *)data;
    }
}

void reduce(int rule){

}

void goTo(int token){
    push(tokenStack, TOKEN, token);
}

void shift(int state, int token){
    push(stateStack, STATE, state);
    goTo(token);
}




struct Stack *stateStack;
struct Stack *tokenStack;

int main(){
    stateStack = createStack();
    tokenStack = createStack();

    //compile the regex pattern
    regexVal = regcomp(&regex, "[a-zA-Z0-9]+|[^[:alnum:]]", REG_EXTENDED);

    if (regexVal) {
    fprintf(stderr, "Regex compilation error\n");
    return 1;
}

    //start reading input
    while (fgets(msgbuf, sizeof(msgbuf), stdin)){
        if (msgbuf == NULL) break;
        
        //execute search
        regexVal = regexec(&regex, msgbuf, 1, match, 0);

        int lastPtr = 0;
        
        int i = 0;
        //look for all matches in the line
        while (regexVal == 0){

            int startBuffer = match[0].rm_so;
            int endBuffer = match[0].rm_eo;
            int len = endBuffer - startBuffer;

            //copy the match to a string
            char tokenStr[len+1];
            strncpy(tokenStr, msgbuf+lastPtr+startBuffer, len);
            tokenStr[len] = '\0';
        
            //tokenize and add to array
            if (!isspace((int) tokenStr[0])){
                struct token token = tokenize(tokenStr, len);
                tokens[i] = token;
                i++;
            }

            //go to next match
            lastPtr += endBuffer;
            regexVal = regexec(&regex, msgbuf + lastPtr, 1, match, 0);
        }

        //parsing block









    }
    push(stateStack, STATE, 0);
    while (1){
        if (tokenIndex == sizeof(tokens)/sizeof(tokens[0])){
            printf("Error!\n");
        }
        struct token nextToken = tokens[tokenIndex+1];
        int action[] = table[peek(stateStack)][nextToken.type];
        switch (action[0]){
            case -1: {
                if (tokens[1].type != EQ) printf("%s", ((struct token *) peek(tokenStack))->value);
                return 0;
            }
            case 0: printf("Error!\n"); return 0;
            case 1: shift(action[1], nextToken.type); tokenIndex++; break;
            case 2: reduce(action[1]); break;
            case 3: goTo(nextToken.type); tokenIndex++; break;
        }

    }


    regfree(&regex);
    return 0;

}

